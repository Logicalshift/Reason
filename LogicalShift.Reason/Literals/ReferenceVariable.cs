using LogicalShift.Reason.Api;
using LogicalShift.Reason.Assignment;
using System;
using System.Collections.Generic;

namespace LogicalShift.Reason.Literals
{
    /// <summary>
    /// Variable representing a reference generated by unification
    /// </summary>
    public class ReferenceVariable : ILiteral, IEquatable<ReferenceVariable>
    {
        /// <summary>
        /// Identifier used to distinguish references from different unification operations
        /// </summary>
        private ILiteral _identifier;

        /// <summary>
        /// Address that identifies this variable withina particular unification
        /// </summary>
        private int _address;

        public ReferenceVariable(ILiteral identifier, int address)
        {
            if (identifier == null) throw new ArgumentNullException("identifier");

            _identifier = identifier;
            _address = address;
        }

        public IEnumerable<IAssignmentLiteral> Flatten()
        {
            yield return new VariableAssignment(new Variable(), this);
        }

        public ILiteral RebuildWithParameters(IEnumerable<ILiteral> parameters)
        {
            return this;
        }

        public IEnumerable<ILiteral> Dependencies
        {
            get { yield break; }
        }

        public ILiteral UnificationKey
        {
            get { return null; }
        }

        public bool Equals(ILiteral other)
        {
            return Equals(other as ReferenceVariable);
        }

        public bool Equals(ReferenceVariable other)
        {
            if (other == null) return false;
            return _address == other._address && Equals(_identifier, other._identifier);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as ReferenceVariable);
        }

        public override int GetHashCode()
        {
            return _identifier.GetHashCode() * 397 + _address.GetHashCode();
        }

        public override string ToString()
        {
            if (_address >= 0)
            {
                return string.Format("ref[{0}]_{1}", _identifier, _address);
            }
            else
            {
                return string.Format("ref[{0}]_X{1}", _identifier, -_address);
            }
        }
    }
}
